\section{Pruebas}

\subsection{Pruebas de arquitectura}

\subsubsection{Pruebas de desarrollo}
Uno de los mayores retos del proyecto ha sido conseguir una arquitectura sólida que satisficiera nuestras necesidades de conexión. La evolución de la generación de la aplicación ha llevado implícitas las pruebas diarias del éxito del diseño y la implementación de nuestro \emph{pipeline}. Por eso detallamos los cambios del mismo, como resultado de nuestros experimentos.

La primera visión del diseño global era mucho más simple que la que finalmente hemos acabado usando: los módulos sólo se conectaban en forma de árbol. Pronto tuvimos que abandonar este enfoque, pues los requisitos de conexión de módulos se mostraron más complejos de lo que estimamos en un principio.

Así pues, pensamos en conectar los módulos \emph{1 a 1} en forma lineal. Los primeros resultados fueron satisfactorios: los módulos se comunicaban una vez que la implementación del diseño dejó de tener errores. La implementación en este punto comenzaba a ser sólida, y pronto ampliamos el diseño para que los módulos tuvieran conexiones de \emph{1 a N}. Con esto conseguimos, por ejemplo, ver las imágenes que generaban los filtros sin tener que cambiar en absoluto los módulos que operaban. El diseño comenzaba a dar sus frutos, empezábamos a ahorrar horas de trabajos y a reutilizar fuertemente el código desarrollado, ya que un módulo de ``ventana de imágenes'' podía, instanciándose varias veces, presentar diferentes imágenes.

El diseño ya comenzaba a ser realmente sólido, sin embargo, nos vimos en la necesidad de que un módulo aceptase varias entradas. Por tanto, añadimos esa funcionalidad. En esta fase del diseño completamos casi toda la aplicación. Las pruebas y la corrección de errores fueron paralelas y terminaron por dar con un conjunto muy fiable, con conexiones \emph{N a N}.

En última instancia, nos dimos cuenta de que el sistema de puertos no era del todo completo. Un módulo sólo se podía conectar a otro por un puerto. Esto nos presentaba el inconveniente en el módulo de cálculo de respuesta, que debía ofrecer la salida de la orden y el parámetro de forma independiente. Finalmente, pues, añadimos más potencia a los puertos, dotando a la estructura de una completitud amplia y sólida.

Como ejemplo global de pruebas y de la utilidad de la arquitectura de \emph{pipeline}, podemos reseñar el del módulo de ``gestión''. Poco valorado al principio, pensamos que iba a ser un simple trámite de la salida global. Sin embargo, finalmente el diagrama total tiene 4 instancias del módulo, para las cuales no hemos tenido que reprogramar nada, sólo variar el archivo de proyecto XML.

\subsubsection{Eficiencia}

El \emph{pipeline} no es un ejemplo de velocidad de proceso. Las pruebas que hemos realizado nos han permitido, en un ordenador con un microprocesador \emph{Intel Pentium IV} con una frecuencia de reloj de $3.0$ GHz, alcanzar velocidades de ciclo de 200 milisegundos. Para una aplicación del ámbito docente como es la que presentamos, el resultado es desde luego más que suficiente, pero no deja de ser un tiempo de ejecución lento para requisitos como, por ejemplo, de tiempo real. 

\subsubsection{Comprobación de los módulos}
A continuación detallamos las pruebas del aspecto arquitectónico de los módulos:
\begin{itemize}
\item \textbf{Generación imágenes y ventana de imágenes}: El resultado esperado de este módulo era la generación de imágenes desde diversas fuentes, en un formato unificado. Para esto, usamos principalmente la ventana de imágenes, comprobando que las imágenes correspondiesen a lo esperado. Para ejemplos de resultados, puede remitirse a la sección \ref{imagenes_ejemplos_graficos}.

\item \textbf{Filtros}:
\item \textbf{Parámetros}: El módulo de generación de parámetros tuvo algunos inconvenientes. En un principio, hicimos un programa con el código base de lo que iba a ser el módulo, consistente en una ventana que generaba estructuras de datos con los valores elegidos. El funcionamiento del programa fue exitoso, cosa que vimos imprimiendo por pantalla el contenido de dichas estructuras. Cuando integramos el módulo (ya programado como tal) en la aplicación, tuvimos algunos problemas, pues los mensajes no llegaban bien al módulo de filtros. Las pruebas nos llevaron a la conclusión de que fue un fallo de arquitectura, con lo que tuvimos que remodelar el diseño del núcleo del pipeline para que admitiese más tipos de conexiones. Tras esto, el resultado fue satisfactorio. 
\item \textbf{OCR}:
\item \textbf{Gestión de mensajes}: La gestión de mensajes fue probada a través de su funcionamiento, y mostrando la salida por consola. La comprobación de la corrección la hemos realizado imprimiendo por la salida estándar el estado del grafo de mensajes en todo momento.
\item \textbf{Post-gestión de órdenes}: El módulo de gestión total de la tubería de órdenes ha tenido pruebas triviales, debido a su sencillez, simplemente, hemos certificado mediante el uso que las órdenes llegaban bien a los módulos de salida.
\item \textbf{Proceso de texto}: El proceso de texto ha sido implementado en Prolog, por lo que las pruebas han sido realizadas de una manera externa a la aplicación, con el intérprete de SWI-Prolog. Gracias a este método, el desarrollo fue más rápido, ya que la comprobación conun intérprete es muy ágil. Cuando funcionó por separado, la integración en la aplicación principal no causó ningún problema, y funcionó tal y como lo habíamos previsto, con lo que no hizo falta realizar más pruebas que la pura comprobación del funcionamiento en ejecuciones normales.
\item \textbf{Robot}: El desarrollo del robot tuvo un trabajo paralelo. Al principio, las pruebas fueron paralelas a la construcción de la estructura, y controlábamos los motores mediante un control de corriente contínua. Las pruebas nos llevaron a la conclusión de que había que remodelar los árboles de engranajes y los cambios de par, pues en un principio no suministraban la suficiente potencia como para mover todo el peso de la estructura. Tuvimos que cambiar esto, y fue un cambio bastante grande. Una vez que el robot se movía con el control remoto, probamos a crear el circuito que iba a hacer de capa entre el puerto paralelo y los motores. Conectamos el circuito, y sobre la placa las tensiones funcionaban bien. Lo ensamblamos al robot, y, aunque en un principio funcionaba bien, pronto dejó de hacerlo. Tras depurar, vimos que había un fallo en un punto de la placa (nos costó bastante averiguarlo), y, una vez corregido esto, el robot comenzó a funcionar de una manera muy estable.
\item \textbf{Red neuronal}:
\item \textbf{Entorno 3D}:
\item \textbf{Salida de texto}: Para las pruebas de la salida de texto simplemente hemos comprobado que el texto que mandábamos al módulo salía por la ventana, añadimos un ejemplo:

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.5,bb=0 0 410 307]{salida_texto.png}
% robot1.png: 72.009dpi, width=5.68cm, height=4.27cm, bb=0 0 161 121
  \caption{Salida de texto}
\end{figure}

\item \textbf{Joystick}: La comprobación del módulo de joystick se ha ido haciendo a medida que la integración avanzaba. Al ser un módulo que se ha desarrollado en la fase final de la aplicación, la estructura de la misma ya estaba bastante sólida, y el funcionamiento del módulo ha sido casi inmediato.
\end{itemize}
